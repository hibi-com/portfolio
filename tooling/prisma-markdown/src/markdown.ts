import type { DMMF } from "@prisma/generator-helper";
import type { Chapter } from "./chapter.js";
import type { Config } from "./config.js";
import { map } from "./utils/map.js";
import { prisma } from "./utils/prisma.js";
import { description } from "./writers/description.js";
import { mermaid } from "./writers/mermaid.js";

interface ChapterInternal {
    name: string;
    descriptions: Set<DMMF.Model>;
    diagrams: Set<DMMF.Model>;
}

export namespace PrismaMarkdown {
    export const write = (schema: DMMF.Datamodel, configParam?: Config | undefined): string => {
        const chapters: Chapter[] = categorize(schema);
        const title: string = configParam?.title ?? "Prisma Markdown";
        const frontMatter: string = ["---", `title: "${title}"`, "---"].join("\n");
        const preface: string = [
            `# ${title}`,
            "",
            "> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)",
            "",
            ...chapters.map(({ name }) => `- [${name}](#${name.toLowerCase()})`),
        ].join("\n");
        if (chapters.length === 0) return [frontMatter, "", preface].join("\n");
        return [frontMatter, "", preface, "", chapters.map((chapter) => writeChapter(chapter)).join("\n\n"), ""].join(
            "\n",
        );
    };

    export const writeChapter = (chapterParam: Chapter): string =>
        [
            `## ${chapterParam.name}`,
            "",
            ...(chapterParam.diagrams.length > 0 ? [mermaid.write(chapterParam.diagrams)] : []),
            ...(chapterParam.diagrams.length > 0 && chapterParam.descriptions.length > 0 ? [""] : []),
            ...(chapterParam.descriptions.length > 0
                ? [chapterParam.descriptions.map((c) => description.table(c)).join("\n\n")]
                : []),
        ].join("\n");

    export const writeDiagram = (diagrams: DMMF.Model[]): string => mermaid.write(diagrams);

    export const writeDescription = (model: DMMF.Model): string => description.table(model);

    export const categorize = (schema: DMMF.Datamodel): Chapter[] => {
        const dict: Map<string, ChapterInternal> = new Map();
        const modelList: DMMF.Model[] = schema.models.filter((model) => !isHidden(model));
        findImplicits(modelList);

        const emplace = (name: string) =>
            map.take(dict)(name, () => ({
                name,
                descriptions: new Set<DMMF.Model>(),
                diagrams: new Set<DMMF.Model>(),
            }));

        for (const model of modelList) {
            const namespaces: string[] = takeTags("namespace")(model);
            if (namespaces.length === 0) continue;

            const top: string = namespaces[0]!;
            const chapterParam: ChapterInternal = emplace(top);
            chapterParam.descriptions.add(model);
            chapterParam.diagrams.add(model);
        }

        for (const model of modelList) {
            const namespaces: string[] = takeTags("namespace")(model);
            for (const name of namespaces.slice(1)) {
                const section = emplace(name);
                section.descriptions.add(model);
                section.diagrams.add(model);
            }
        }

        for (const model of modelList) {
            const describes: string[] = takeTags("describe")(model);
            for (const name of describes) {
                const chapterParam: ChapterInternal = map.take(dict)(name, () => ({
                    name,
                    descriptions: new Set<DMMF.Model>(),
                    diagrams: new Set<DMMF.Model>(),
                }));
                chapterParam.descriptions.add(model);
            }
        }

        for (const model of modelList) {
            const erdList: string[] = takeTags("erd")(model);
            for (const erd of erdList) {
                const chapterParam: ChapterInternal = map.take(dict)(erd, () => ({
                    name: erd,
                    descriptions: new Set<DMMF.Model>(),
                    diagrams: new Set<DMMF.Model>(),
                }));
                chapterParam.diagrams.add(model);
            }
        }

        for (const model of modelList) {
            const keywords: string[] = [
                ...takeTags("namespace")(model),
                ...takeTags("describe")(model),
                ...takeTags("erd")(model),
            ];
            if (keywords.length !== 0) continue;

            const basic: ChapterInternal = map.take(dict)("default", () => ({
                name: "default",
                descriptions: new Set<DMMF.Model>(),
                diagrams: new Set<DMMF.Model>(),
            }));
            basic.descriptions.add(model);
            basic.diagrams.add(model);
        }

        return Array.from(dict.values())
            .filter((c) => !!c.descriptions.size || !!c.diagrams.size)
            .map((chapter) => ({
                name: chapter.name,
                descriptions: Array.from(chapter.descriptions),
                diagrams: Array.from(chapter.diagrams),
            }));
    };

    const takeTags =
        (kind: "namespace" | "describe" | "erd") =>
        (model: DMMF.Model): string[] => [
            ...new Set(
                prisma
                    .tagValues(kind)(model)
                    .map((str: string) => str.split(" ")[0])
                    .filter((s): s is string => s !== undefined),
            ),
        ];

    const isHidden = (model: DMMF.Model): boolean => model.documentation?.includes("@hidden") ?? false;

    const findImplicits = (modelList: DMMF.Model[]) => {
        const dict: Map<string, DMMF.Model> = new Map();
        for (const model of modelList) {
            for (const field of model.fields) {
                const implicitRelation = findImplicitRelation(model, field, modelList);
                if (implicitRelation === null) continue;

                const table = implicitRelation.tableName;
                if (dict.has(table)) continue;

                const newbie: DMMF.Model = implicitToExplicit(implicitRelation.model)(implicitRelation.opposite);
                modelList.push(newbie);
                dict.set(table, newbie);
            }
        }
    };

    const findImplicitRelation = (
        model: DMMF.Model,
        field: DMMF.Field,
        modelList: DMMF.Model[],
    ): { model: DMMF.Model; opposite: DMMF.Model; tableName: string } | null => {
        if (!isImplicitRelationField(field)) return null;

        const opposite = modelList.find((m) => m.name === field.type);
        if (opposite === undefined) return null;

        const oppositeField = opposite.fields.find((f) => f.kind === "object" && f.isList && f.type === model.name);
        if (oppositeField === undefined || model === opposite) return null;

        const relations: DMMF.Model[] = [model, opposite].sort((x, y) => x.name.localeCompare(y.name));
        const tableName = `_${relations[0]?.name ?? ""}To${relations[1]?.name ?? ""}`;

        return { model: relations[0]!, opposite: relations[1]!, tableName };
    };

    const isImplicitRelationField = (field: DMMF.Field): boolean => {
        return field.kind === "object" && field.isList === true && field.isUnique === false;
    };

    const implicitToExplicit =
        (x: DMMF.Model) =>
        (y: DMMF.Model): DMMF.Model => {
            const name: string = `_${x.name}To${y.name}`;
            const tagger = (kind: "namespace" | "describe" | "erd"): string[] =>
                [...new Set([...takeTags(kind)(x), ...takeTags(kind)(y)])].map((value) => `@${kind} ${value}`);
            const description: string[] = [
                `Pair relationship table between {@link ${x.dbName ?? x.name}} and {@link ${y.dbName ?? y.name}}`,
                "",
                ...tagger("describe"),
                ...tagger("erd"),
                ...tagger("namespace"),
            ];
            if (description.length === 2) description.splice(1, 1);

            const newbie: DMMF.Model = {
                name,
                dbName: null,
                schema: null,
                fields: [
                    {
                        kind: "scalar",
                        name: "A",
                        type: x.primaryKey?.fields?.[0] ?? "String",
                        isRequired: true,
                        isList: false,
                        isUnique: false,
                        isId: false,
                        isReadOnly: false,
                        hasDefaultValue: false,
                    },
                    {
                        kind: "scalar",
                        name: "B",
                        type: y.primaryKey?.fields?.[0] ?? "String",
                        isRequired: true,
                        isList: false,
                        isUnique: false,
                        isId: false,
                        isReadOnly: false,
                        hasDefaultValue: false,
                    },
                    {
                        kind: "object",
                        name: x.name,
                        type: x.name,
                        isRequired: true,
                        isList: false,
                        isUnique: false,
                        isId: false,
                        isReadOnly: false,
                        hasDefaultValue: false,
                        relationToFields: [x.primaryKey?.fields?.[0] ?? "id"],
                        relationFromFields: ["A"],
                    },
                    {
                        kind: "object",
                        name: y.name,
                        type: y.name,
                        isRequired: true,
                        isList: false,
                        isUnique: false,
                        isId: false,
                        isReadOnly: false,
                        hasDefaultValue: false,
                        relationToFields: [y.primaryKey?.fields?.[0] ?? "id"],
                        relationFromFields: ["B"],
                    },
                ],
                uniqueFields: [["A", "B"]],
                uniqueIndexes: [],
                primaryKey: null,
                documentation: description.join("\n"),
            };
            (x.fields as DMMF.Field[]).push({
                kind: "object",
                name,
                type: name,
                isRequired: true,
                isList: true,
                isUnique: false,
                isId: false,
                isReadOnly: false,
                hasDefaultValue: false,
                relationToFields: ["A"],
            });
            (y.fields as DMMF.Field[]).push({
                kind: "object",
                name,
                type: name,
                isRequired: true,
                isList: true,
                isUnique: false,
                isId: false,
                isReadOnly: false,
                hasDefaultValue: false,
                relationToFields: ["B"],
            });
            return newbie;
        };
}
