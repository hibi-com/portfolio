---
title: "API設計ガイドライン"
---

このドキュメントは、本プロジェクトの REST API 設計と実装に適用する**必須のガイドライン**である。  
TypeSpec で OpenAPI 仕様を定義し、Orval で TypeScript クライアントを生成、Hono でエンドポイントを実装する構成を前提とする。  
実装の詳細はリポジトリの `packages/api`・`apps/api` を参照すること。

## 方針と責務

- **API 仕様は TypeSpec で一元定義する**。OpenAPI は TypeSpec の emit 結果とし、手書きの OpenAPI ファイルで仕様を管理しない。
- **クライアントは Orval で生成する**。生成元は OpenAPI 仕様のみとし、生成物は `packages/api` の生成ディレクトリに出力する。
- **エンドポイントは Hono で実装する**。BFF としてフロントから呼ばれる REST は、すべて Hono のルーターで定義する。

## REST API の設計ルール

### エンドポイント

- 一覧取得は複数形のリソース名（例: `/api/posts`）とし、GET で取得する。
- 単一取得はスラッグまたは ID をパスに含める（例: `/api/post/:slug`）。クエリのみで ID を渡す設計は避ける。
- 新規作成・更新・削除は、HTTP メソッド（POST / PUT または PATCH / DELETE）とパスで一意に決まるようにする。
- エンドポイント一覧と役割は `docs/specs/api/` および TypeSpec のルート定義を参照すること。

### 必須とする仕様化

- 各オペレーションにルート・メソッド・要約を TypeSpec で明示する。未定義のエンドポイントを実装してはならない。
- リクエスト・レスポンスの型は TypeSpec のモデルで定義する。レスポンスに「任意の JSON」を返す仕様は禁止する。
- エラー応答も TypeSpec またはプロジェクト共通のエラー形式（`docs/specs/error-codes.md`）に従い、仕様に含める。

## エラーハンドリング（必須）

### レスポンス形式

- エラー時は JSON で `error`（必須）と、必要に応じて `details` を返す。クライアントが原因を判別できるメッセージを返すこと。
- 成功時とエラー時でフィールド構成を揃え、クライアントが `error` の有無で判定できるようにする。

### HTTP ステータスコード

- **200**: 成功。body に仕様通りのデータを返す。
- **400**: クライアント起因の不正（バリデーションエラー、不正なスラッグ等）。`error` で理由を明示する。
- **404**: 指定したリソースが存在しない。汎用メッセージではなく「どのリソースが無いか」が分かる文言とする。
- **500**: サーバー内部エラー。本番では `details` に機密を含めない。ログには必ず記録する。

### 禁止事項

- 曖昧なエラーメッセージ（例: `"Error"` のみ）を返してはならない。
- クライアントの入力不備とサーバー障害を同じステータスで返してはならない（400 と 500 を区別する）。
- 例外を握りつぶして 200 を返してはならない。失敗時は必ず適切な 4xx/5xx とエラー body を返す。

## 入力バリデーション

- パスパラメータ・クエリ・body は、TypeSpec およびサーバー側で一貫したルールで検証する。
- スラッグなど識別子は、許可する文字・形式を仕様と実装の両方で定義し、不正な値は 400 で拒否する。
- サーバー側のバリデーションは `packages/validation` または `apps/api` の検証ロジックを参照し、Zod 等で仕様と整合させる。

## 実装の責務

### エンドポイントハンドラー

- ハンドラー内で DB や UseCase の有無を確認し、利用できない場合は 500 を返す。未チェックの null 参照を返してはならない。
- UseCase の実行結果に応じて、存在しない場合は 404、バリデーション違反は 400、それ以外の例外はログを取ったうえで 500 とエラー body を返す。
- 成功時は TypeSpec/OpenAPI で定義した型に沿った JSON のみを返す。余計なフィールドを追加しない。

### ルーター

- ルートと HTTP メソッドは TypeSpec の定義と一致させる。未定義のパスを公開してはならない。
- ルーターの統合場所は `apps/api` の REST 用エントリを参照すること。

### クライアント利用

- フロント・BFF から API を呼ぶ場合は、Orval 生成クライアントを利用する。生の fetch/axios で URL を直書きしてはならない（生成クライアントのラッパーで URL を集約する）。
- ベース URL は環境に応じて切り替え、生成クライアントの設定（mutator 等）で一元管理する。実装は `packages/api` の生成物と各アプリの API ラッパーを参照すること。

## 型の共有

- リクエスト・レスポンスの型は OpenAPI 由来の生成型を使う。クライアント・サーバー間で別定義の型を「同じ」として扱ってはならない。
- 生成型は `packages/api` の生成出力から export し、他パッケージはそこから import する。型の二重定義をしない。

## ログと観測性

- エラー時（特に 500 にした場合）は、必ずサーバー側でログに記録する。スタックトレースやリクエスト識別子を含め、本番では機密をマスクする。
- エラーレスポンスの `details` に、本番で機密情報（DB 内部、内部ホスト名等）を出さない。

## テスト

- API の振る舞い（ステータスコード・body の形）は E2E または統合テストで検証する。テストは `docs/testing/testing-guide.md` に従い、仕様・シーケンスと対応させる。
- モックが必要な場合は MSW 等でハンドラーを定義し、生成クライアントと同じエンドポイント・形式を使う。実装はリポジトリのテスト・モック配置を参照すること。

## 生成とビルド

- OpenAPI 仕様の生成は TypeSpec の compile で行う。実行方法はルートの `package.json` および `packages/api` のスクリプトを参照する（`bun run` のみ使用。bunx 直接利用は [コマンド追加リスト](../../scripts/command-addition-list.md) に従う）。
- Orval によるクライアント生成は、OpenAPI 出力を入力として実行する。設定は `packages/api` の Orval 設定ファイルを参照すること。

## 参考資料

- [TypeSpec ドキュメント](https://typespec.io/)
- [Orval ドキュメント](https://orval.dev/)
- [Hono ドキュメント](https://hono.dev/)
- [OpenAPI 仕様](https://swagger.io/specification/)
- プロジェクト内: [エラーコード仕様](../specs/error-codes.md)、[バリデーション仕様](../specs/validation.md)
